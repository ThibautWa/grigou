{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///home/thib/Grigou_v3/git/src/lib/db.ts"],"sourcesContent":["import { Pool } from 'pg';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport default pool;\n\nexport interface Transaction {\n  id: number;\n  type: 'income' | 'outcome';\n  amount: number;\n  description: string;\n  category: string | null;\n  date: string;\n  created_at: Date;\n  updated_at: Date;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAC5C;uCAEe","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///home/thib/Grigou_v3/git/src/app/api/predictions/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport pool from '@/lib/db';\nimport { addDays, addWeeks, addMonths, addYears, isBefore, isAfter, format } from 'date-fns';\n\ninterface RecurringTransaction {\n  id: number;\n  type: 'income' | 'outcome';\n  amount: string;\n  description: string;\n  category: string | null;\n  date: string;\n  is_recurring: boolean;\n  recurrence_type: 'daily' | 'weekly' | 'biweekly' | 'monthly' | 'bimonthly' | 'quarterly' | 'yearly';\n  recurrence_end_date: string | null;\n}\n\nfunction getNextOccurrence(\n  startDate: Date,\n  recurrenceType: string\n): Date {\n  switch (recurrenceType) {\n    case 'daily':\n      return addDays(startDate, 1);\n    case 'weekly':\n      return addWeeks(startDate, 1);\n    case 'biweekly':\n      return addWeeks(startDate, 2);\n    case 'monthly':\n      return addMonths(startDate, 1);\n    case 'bimonthly':\n      return addMonths(startDate, 2);\n    case 'quarterly':\n      return addMonths(startDate, 3);\n    case 'yearly':\n      return addYears(startDate, 1);\n    default:\n      return addMonths(startDate, 1);\n  }\n}\n\nfunction generatePredictions(\n  transaction: RecurringTransaction,\n  endDate: Date\n): any[] {\n  const predictions = [];\n  let currentDate = new Date(transaction.date);\n  const maxDate = transaction.recurrence_end_date\n    ? new Date(transaction.recurrence_end_date)\n    : endDate;\n\n  // Limiter à la date la plus proche (recurrence_end_date ou endDate)\n  const limitDate = isBefore(maxDate, endDate) ? maxDate : endDate;\n\n  // Générer les occurrences futures\n  while (true) {\n    currentDate = getNextOccurrence(currentDate, transaction.recurrence_type);\n\n    if (isAfter(currentDate, limitDate)) {\n      break;\n    }\n\n    predictions.push({\n      id: `predicted-${transaction.id}-${currentDate.getTime()}`,\n      type: transaction.type,\n      amount: parseFloat(transaction.amount),\n      description: transaction.description,\n      category: transaction.category,\n      date: format(currentDate, 'yyyy-MM-dd'),\n      is_predicted: true,\n      original_transaction_id: transaction.id,\n    });\n  }\n  console.log('Generated predictions:', predictions);\n  return predictions;\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const startDate = searchParams.get('startDate');\n    const endDate = searchParams.get('endDate');\n\n    if (!startDate || !endDate) {\n      return NextResponse.json(\n        { error: 'startDate et endDate sont requis' },\n        { status: 400 }\n      );\n    }\n\n    const startDateObj = new Date(startDate);\n    const endDateObj = new Date(endDate);\n\n    // Récupérer la date la plus ancienne des transactions récurrentes\n    const oldestRecurringResult = await pool.query(\n      `SELECT MIN(date) as oldest_date \n       FROM transactions \n       WHERE is_recurring = true`\n    );\n    \n    const oldestRecurringDate = oldestRecurringResult.rows[0]?.oldest_date || startDate;\n\n    // Récupérer TOUTES les transactions récurrentes actives\n    // en utilisant la date la plus ancienne comme référence\n    const result = await pool.query<RecurringTransaction>(\n      `SELECT * FROM transactions \n       WHERE is_recurring = TRUE \n       AND date <= $1\n       AND (recurrence_end_date IS NULL OR recurrence_end_date >= $2)\n       ORDER BY date ASC`,\n      [endDate, oldestRecurringDate]  // ✅ Utilisation de la date la plus ancienne\n    );\n\n    console.log('Date range:', startDate, 'to', endDate);\n    console.log('Oldest recurring date:', oldestRecurringDate);\n    console.log('Recurring transactions found:', result.rows.length);\n\n    const recurringTransactions = result.rows;\n    let allPredictions: any[] = [];\n\n    // Générer les prédictions pour chaque transaction récurrente\n    for (const transaction of recurringTransactions) {\n      const predictions = generatePredictions(transaction, endDateObj);\n      allPredictions = [...allPredictions, ...predictions];\n    }\n\n    // Filtrer uniquement par la période demandée\n    const filteredPredictions = allPredictions.filter(pred => {\n      const predDate = new Date(pred.date);\n      return predDate >= startDateObj && predDate <= endDateObj;\n    });\n\n    // Trier par date\n    filteredPredictions.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n\n    console.log('Predictions generated:', filteredPredictions.length);\n\n    return NextResponse.json(filteredPredictions);\n  } catch (error) {\n    console.error('Error generating predictions:', error);\n    return NextResponse.json(\n      { error: 'Erreur lors de la génération des prédictions' },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAcA,SAAS,kBACP,SAAe,EACf,cAAsB;IAEtB,OAAQ;QACN,KAAK;YACH,OAAO,IAAA,mJAAO,EAAC,WAAW;QAC5B,KAAK;YACH,OAAO,IAAA,qJAAQ,EAAC,WAAW;QAC7B,KAAK;YACH,OAAO,IAAA,qJAAQ,EAAC,WAAW;QAC7B,KAAK;YACH,OAAO,IAAA,uJAAS,EAAC,WAAW;QAC9B,KAAK;YACH,OAAO,IAAA,uJAAS,EAAC,WAAW;QAC9B,KAAK;YACH,OAAO,IAAA,uJAAS,EAAC,WAAW;QAC9B,KAAK;YACH,OAAO,IAAA,qJAAQ,EAAC,WAAW;QAC7B;YACE,OAAO,IAAA,uJAAS,EAAC,WAAW;IAChC;AACF;AAEA,SAAS,oBACP,WAAiC,EACjC,OAAa;IAEb,MAAM,cAAc,EAAE;IACtB,IAAI,cAAc,IAAI,KAAK,YAAY,IAAI;IAC3C,MAAM,UAAU,YAAY,mBAAmB,GAC3C,IAAI,KAAK,YAAY,mBAAmB,IACxC;IAEJ,oEAAoE;IACpE,MAAM,YAAY,IAAA,qJAAQ,EAAC,SAAS,WAAW,UAAU;IAEzD,kCAAkC;IAClC,MAAO,KAAM;QACX,cAAc,kBAAkB,aAAa,YAAY,eAAe;QAExE,IAAI,IAAA,mJAAO,EAAC,aAAa,YAAY;YACnC;QACF;QAEA,YAAY,IAAI,CAAC;YACf,IAAI,CAAC,UAAU,EAAE,YAAY,EAAE,CAAC,CAAC,EAAE,YAAY,OAAO,IAAI;YAC1D,MAAM,YAAY,IAAI;YACtB,QAAQ,WAAW,YAAY,MAAM;YACrC,aAAa,YAAY,WAAW;YACpC,UAAU,YAAY,QAAQ;YAC9B,MAAM,IAAA,iKAAM,EAAC,aAAa;YAC1B,cAAc;YACd,yBAAyB,YAAY,EAAE;QACzC;IACF;IACA,QAAQ,GAAG,CAAC,0BAA0B;IACtC,OAAO;AACT;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,UAAU,aAAa,GAAG,CAAC;QAEjC,IAAI,CAAC,aAAa,CAAC,SAAS;YAC1B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmC,GAC5C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,eAAe,IAAI,KAAK;QAC9B,MAAM,aAAa,IAAI,KAAK;QAE5B,kEAAkE;QAClE,MAAM,wBAAwB,MAAM,6HAAI,CAAC,KAAK,CAC5C,CAAC;;gCAEyB,CAAC;QAG7B,MAAM,sBAAsB,sBAAsB,IAAI,CAAC,EAAE,EAAE,eAAe;QAE1E,wDAAwD;QACxD,wDAAwD;QACxD,MAAM,SAAS,MAAM,6HAAI,CAAC,KAAK,CAC7B,CAAC;;;;wBAIiB,CAAC,EACnB;YAAC;YAAS;SAAoB,CAAE,4CAA4C;;QAG9E,QAAQ,GAAG,CAAC,eAAe,WAAW,MAAM;QAC5C,QAAQ,GAAG,CAAC,0BAA0B;QACtC,QAAQ,GAAG,CAAC,iCAAiC,OAAO,IAAI,CAAC,MAAM;QAE/D,MAAM,wBAAwB,OAAO,IAAI;QACzC,IAAI,iBAAwB,EAAE;QAE9B,6DAA6D;QAC7D,KAAK,MAAM,eAAe,sBAAuB;YAC/C,MAAM,cAAc,oBAAoB,aAAa;YACrD,iBAAiB;mBAAI;mBAAmB;aAAY;QACtD;QAEA,6CAA6C;QAC7C,MAAM,sBAAsB,eAAe,MAAM,CAAC,CAAA;YAChD,MAAM,WAAW,IAAI,KAAK,KAAK,IAAI;YACnC,OAAO,YAAY,gBAAgB,YAAY;QACjD;QAEA,iBAAiB;QACjB,oBAAoB,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO;QAExF,QAAQ,GAAG,CAAC,0BAA0B,oBAAoB,MAAM;QAEhE,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+C,GACxD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}