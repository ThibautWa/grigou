{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///home/thib/Grigou_v3/git/src/lib/db.ts"],"sourcesContent":["import { Pool } from 'pg';\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport default pool;\n\nexport interface Transaction {\n  id: number;\n  type: 'income' | 'outcome';\n  amount: number;\n  description: string;\n  category: string | null;\n  date: string;\n  created_at: Date;\n  updated_at: Date;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;AAEA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;AAC5C;uCAEe","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///home/thib/Grigou_v3/git/src/app/api/stats/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport pool from '@/lib/db';\nimport { format } from 'date-fns';\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const startDate = searchParams.get('startDate');\n    const endDate = searchParams.get('endDate');\n    const includePredictions = searchParams.get('includePredictions') === 'true';\n\n    let params: any[] = [];\n    let whereClause = '';\n\n    if (startDate && endDate) {\n      whereClause = 'WHERE date >= $1 AND date <= $2';\n      params = [startDate, endDate];\n    }\n\n    // Get total income and outcome ONLY for the selected period (real transactions)\n    const totalsQuery = `\n      SELECT \n        COALESCE(SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END), 0) as total_income,\n        COALESCE(SUM(CASE WHEN type = 'outcome' THEN amount ELSE 0 END), 0) as total_outcome\n      FROM transactions\n      ${whereClause}\n    `;\n\n    const totalsResult = await pool.query(totalsQuery, params);\n    const totals = totalsResult.rows[0];\n\n    // Initialize with real transactions\n    let periodIncome = parseFloat(totals.total_income);\n    let periodOutcome = parseFloat(totals.total_outcome);\n\n    console.log('Real transactions for period - Income:', periodIncome, 'Outcome:', periodOutcome);\n\n    // Calculate cumulative balance (everything from the beginning to endDate)\n    let cumulativeBalance = 0;\n\n    if (endDate) {\n      // Get all real transactions until endDate\n      const allTransactionsQuery = `\n        SELECT \n          COALESCE(SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END), 0) as total_income,\n          COALESCE(SUM(CASE WHEN type = 'outcome' THEN amount ELSE 0 END), 0) as total_outcome\n        FROM transactions\n        WHERE date <= $1\n      `;\n      const allTransactionsResult = await pool.query(allTransactionsQuery, [endDate]);\n      const allTotals = allTransactionsResult.rows[0];\n      cumulativeBalance = parseFloat(allTotals.total_income) - parseFloat(allTotals.total_outcome);\n\n      console.log('Real transactions balance:', cumulativeBalance);\n\n      // Add predictions if requested\n      if (includePredictions) {\n        try {\n          // Get the oldest recurring transaction date\n          const oldestRecurringQuery = `\n            SELECT MIN(date) as oldest_date \n            FROM transactions \n            WHERE is_recurring = true\n          `;\n          const oldestResult = await pool.query(oldestRecurringQuery);\n          const oldestDate = oldestResult.rows[0]?.oldest_date;\n\n          if (oldestDate) {\n            const formattedOldestDate = format(new Date(oldestDate), 'yyyy-MM-dd');\n\n            console.log('Fetching ALL predictions from', formattedOldestDate, 'to', endDate);\n\n            // Fetch ALL predictions from the oldest recurring transaction to endDate\n            const allPredictionsResponse = await fetch(\n              `${request.nextUrl.origin}/api/predictions?startDate=${formattedOldestDate}&endDate=${endDate}`\n            );\n\n            if (allPredictionsResponse.ok) {\n              const allPredictions = await allPredictionsResponse.json();\n\n              console.log('All predictions fetched:', allPredictions.length);\n\n              // Add all predicted amounts to cumulative balance\n              allPredictions.forEach((pred: any) => {\n                if (pred.type === 'income') {\n                  cumulativeBalance += pred.amount;\n                } else {\n                  cumulativeBalance -= pred.amount;\n                }\n              });\n\n              console.log('Cumulative balance after all predictions:', cumulativeBalance);\n            }\n\n            // ✅ NOW fetch predictions for the selected period ONLY (for the cards)\n            if (startDate) {\n              console.log('Fetching period predictions from', startDate, 'to', endDate);\n\n              const periodPredictionsResponse = await fetch(\n                `${request.nextUrl.origin}/api/predictions?startDate=${startDate}&endDate=${endDate}`\n              );\n\n              if (periodPredictionsResponse.ok) {\n                const periodPredictions = await periodPredictionsResponse.json();\n\n                console.log('Period predictions fetched:', periodPredictions.length);\n\n                // Add period predictions to the display totals\n                periodPredictions.forEach((pred: any) => {\n                  if (pred.type === 'income') {\n                    periodIncome += pred.amount;\n                    console.log('Adding period income prediction:', pred.amount);\n                  } else {\n                    periodOutcome += pred.amount;\n                    console.log('Adding period outcome prediction:', pred.amount);\n                  }\n                });\n\n                console.log('Period totals with predictions - Income:', periodIncome, 'Outcome:', periodOutcome);\n              }\n            }\n          }\n        } catch (error) {\n          console.error('Error fetching predictions:', error);\n        }\n      }\n    }\n\n    // Get monthly evolution\n    const evolutionQuery = `\n      SELECT \n        TO_CHAR(date, 'YYYY-MM') as month,\n        COALESCE(SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END), 0) as income,\n        COALESCE(SUM(CASE WHEN type = 'outcome' THEN amount ELSE 0 END), 0) as outcome\n      FROM transactions\n      ${whereClause}\n      GROUP BY TO_CHAR(date, 'YYYY-MM')\n      ORDER BY month\n    `;\n\n    const evolutionResult = await pool.query(evolutionQuery, params);\n\n    const monthlyData = evolutionResult.rows.map((row) => {\n      const income = parseFloat(row.income);\n      const outcome = parseFloat(row.outcome);\n      const monthlyBalance = income - outcome;\n\n      return {\n        month: row.month,\n        income,\n        outcome,\n        balance: monthlyBalance,\n        cumulative: 0,\n        predicted_income: 0,\n        predicted_outcome: 0,\n      };\n    });\n\n    return NextResponse.json({\n      totalIncome: periodIncome,      // ✅ Includes predictions for selected period\n      totalOutcome: periodOutcome,    // ✅ Includes predictions for selected period\n      balance: cumulativeBalance,      // ✅ Cumulative balance with all predictions\n      monthlyData,\n    });\n  } catch (error) {\n    console.error('Error fetching statistics:', error);\n    return NextResponse.json(\n      { error: 'Erreur lors de la récupération des statistiques' },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}